898 File: servers/pm/signal.c MINIX SOURCE CODE
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             servers/pm/signal.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
19500 /* This file handles signals, which are asynchronous events and are generally
19501 * a messy and unpleasant business. Signals can be generated by the KILL
19502 * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
19503 * In all cases control eventually passes to check_sig() to see which processes
19504 * can be signaled. The actual signaling is done by sig_proc().
19505 *
19506 * The entry points into this file are:
19507 * do_sigaction: perform the SIGACTION system call
19508 * do_sigpending: perform the SIGPENDING system call
19509 * do_sigprocmask: perform the SIGPROCMASK system call
19510 * do_sigreturn: perform the SIGRETURN system call
19511 * do_sigsuspend: perform the SIGSUSPEND system call
19512 * do_kill: perform the KILL system call
19513 * do_alarm: perform the ALARM system call by calling set_alarm()
19514 * set_alarm: tell the clock task to start or stop a timer
19515 * do_pause: perform the PAUSE system call
19516 * ksig_pending: the kernel notified about pending signals
19517 * sig_proc: interrupt or terminate a signaled process
19518 * check_sig: check which processes to signal with sig_proc()
19519 * check_pending: check if a pending signal can now be delivered
19520 */
19521
19522 #include "pm.h"
19523 #include <sys/stat.h>
19524 #include <sys/ptrace.h>
19525 #include <minix/callnr.h>
19526 #include <minix/com.h>
19527 #include <signal.h>
19528 #include <sys/sigcontext.h>
19529 #include <string.h>
19530 #include "mproc.h"
19531 #include "param.h"
19532
19533 #define CORE_MODE 0777 /* mode to use on core image files */
19534 #define DUMPED 0200 /* bit set in status when core dumped */
19535
19536 FORWARD _PROTOTYPE( void dump_core, (struct mproc *rmp) );
19537 FORWARD _PROTOTYPE( void unpause, (int pro) );
19538 FORWARD _PROTOTYPE( void handle_sig, (int proc_nr, sigset_t sig_map) );
19539 FORWARD _PROTOTYPE( void cause_sigalrm, (struct timer *tp) );
19540
19541 /*===========================================================================*
19542 * do_sigaction *
19543 *===========================================================================*/
19544 PUBLIC int do_sigaction()
19545 {
19546 int r;
19547 struct sigaction svec;
19548 struct sigaction *svp;
19549
19550 if (m_in.sig_nr == SIGKILL) return(OK);
19551 if (m_in.sig_nr < 1 || m_in.sig_nr > _NSIG) return (EINVAL);
19552 svp = &mp->mp_sigact[m_in.sig_nr];
19553 if ((struct sigaction *) m_in.sig_osa != (struct sigaction *) NULL) {
19554 r = sys_datacopy(PM_PROC_NR,(vir_bytes) svp,
MINIX SOURCE CODE File: servers/pm/signal.c 899
19555 who, (vir_bytes) m_in.sig_osa, (phys_bytes) sizeof(svec));
19556 if (r != OK) return(r);
19557 }
19558
19559 if ((struct sigaction *) m_in.sig_nsa == (struct sigaction *) NULL)
19560 return(OK);
19561
19562 /* Read in the sigaction structure. */
19563 r = sys_datacopy(who, (vir_bytes) m_in.sig_nsa,
19564 PM_PROC_NR, (vir_bytes) &svec, (phys_bytes) sizeof(svec));
19565 if (r != OK) return(r);
19566
19567 if (svec.sa_handler == SIG_IGN) {
19568 sigaddset(&mp->mp_ignore, m_in.sig_nr);
19569 sigdelset(&mp->mp_sigpending, m_in.sig_nr);
19570 sigdelset(&mp->mp_catch, m_in.sig_nr);
19571 sigdelset(&mp->mp_sig2mess, m_in.sig_nr);
19572 } else if (svec.sa_handler == SIG_DFL) {
19573 sigdelset(&mp->mp_ignore, m_in.sig_nr);
19574 sigdelset(&mp->mp_catch, m_in.sig_nr);
19575 sigdelset(&mp->mp_sig2mess, m_in.sig_nr);
19576 } else if (svec.sa_handler == SIG_MESS) {
19577 if (! (mp->mp_flags & PRIV_PROC)) return(EPERM);
19578 sigdelset(&mp->mp_ignore, m_in.sig_nr);
19579 sigaddset(&mp->mp_sig2mess, m_in.sig_nr);
19580 sigdelset(&mp->mp_catch, m_in.sig_nr);
19581 } else {
19582 sigdelset(&mp->mp_ignore, m_in.sig_nr);
19583 sigaddset(&mp->mp_catch, m_in.sig_nr);
19584 sigdelset(&mp->mp_sig2mess, m_in.sig_nr);
19585 }
19586 mp->mp_sigact[m_in.sig_nr].sa_handler = svec.sa_handler;
19587 sigdelset(&svec.sa_mask, SIGKILL);
19588 mp->mp_sigact[m_in.sig_nr].sa_mask = svec.sa_mask;
19589 mp->mp_sigact[m_in.sig_nr].sa_flags = svec.sa_flags;
19590 mp->mp_sigreturn = (vir_bytes) m_in.sig_ret;
19591 return(OK);
19592 }
19594 /*===========================================================================*
19595 * do_sigpending *
19596 *===========================================================================*/
19597 PUBLIC int do_sigpending()
19598 {
19599 mp->mp_reply.reply_mask = (long) mp->mp_sigpending;
19600 return OK;
19601 }
19603 /*===========================================================================*
19604 * do_sigprocmask *
19605 *===========================================================================*/
19606 PUBLIC int do_sigprocmask()
19607 {
19608 /* Note that the library interface passes the actual mask in sigmask_set,
19609 * not a pointer to the mask, in order to save a copy. Similarly,
19610 * the old mask is placed in the return message which the library
19611 * interface copies (if requested) to the user specified address.
19612 *
19613 * The library interface must set SIG_INQUIRE if the ’act’ argument
19614 * is NULL.
900 File: servers/pm/signal.c MINIX SOURCE CODE
19615 */
19616
19617 int i;
19618
19619 mp->mp_reply.reply_mask = (long) mp->mp_sigmask;
19620
19621 switch (m_in.sig_how) {
19622 case SIG_BLOCK:
19623 sigdelset((sigset_t *)&m_in.sig_set, SIGKILL);
19624 for (i = 1; i <= _NSIG; i++) {
19625 if (sigismember((sigset_t *)&m_in.sig_set, i))
19626 sigaddset(&mp->mp_sigmask, i);
19627 }
19628 break;
19629
19630 case SIG_UNBLOCK:
19631 for (i = 1; i <= _NSIG; i++) {
19632 if (sigismember((sigset_t *)&m_in.sig_set, i))
19633 sigdelset(&mp->mp_sigmask, i);
19634 }
19635 check_pending(mp);
19636 break;
19637
19638 case SIG_SETMASK:
19639 sigdelset((sigset_t *) &m_in.sig_set, SIGKILL);
19640 mp->mp_sigmask = (sigset_t) m_in.sig_set;
19641 check_pending(mp);
19642 break;
19643
19644 case SIG_INQUIRE:
19645 break;
19646
19647 default:
19648 return(EINVAL);
19649 break;
19650 }
19651 return OK;
19652 }
19654 /*===========================================================================*
19655 * do_sigsuspend *
19656 *===========================================================================*/
19657 PUBLIC int do_sigsuspend()
19658 {
19659 mp->mp_sigmask2 = mp->mp_sigmask; /* save the old mask */
19660 mp->mp_sigmask = (sigset_t) m_in.sig_set;
19661 sigdelset(&mp->mp_sigmask, SIGKILL);
19662 mp->mp_flags |= SIGSUSPENDED;
19663 check_pending(mp);
19664 return(SUSPEND);
19665 }
19667 /*===========================================================================*
19668 * do_sigreturn *
19669 *===========================================================================*/
19670 PUBLIC int do_sigreturn()
19671 {
19672 /* A user signal handler is done. Restore context and check for
19673 * pending unblocked signals.
19674 */
MINIX SOURCE CODE File: servers/pm/signal.c 901
19675
19676 int r;
19677
19678 mp->mp_sigmask = (sigset_t) m_in.sig_set;
19679 sigdelset(&mp->mp_sigmask, SIGKILL);
19680
19681 r = sys_sigreturn(who, (struct sigmsg *) m_in.sig_context);
19682 check_pending(mp);
19683 return(r);
19684 }
19686 /*===========================================================================*
19687 * do_kill *
19688 *===========================================================================*/
19689 PUBLIC int do_kill()
19690 {
19691 /* Perform the kill(pid, signo) system call. */
19692
19693 return check_sig(m_in.pid, m_in.sig_nr);
19694 }
19696 /*===========================================================================*
19697 * ksig_pending *
19698 *===========================================================================*/
19699 PUBLIC int ksig_pending()
19700 {
19701 /* Certain signals, such as segmentation violations originate in the kernel.
19702 * When the kernel detects such signals, it notifies the PM to take further
19703 * action. The PM requests the kernel to send messages with the process
19704 * slot and bit map for all signaled processes. The File System, for example,
19705 * uses this mechanism to signal writing on broken pipes (SIGPIPE).
19706 *
19707 * The kernel has notified the PM about pending signals. Request pending
19708 * signals until all signals are handled. If there are no more signals,
19709 * NONE is returned in the process number field.
19710 */
19711 int proc_nr;
19712 sigset_t sig_map;
19713
19714 while (TRUE) {
19715 sys_getksig(&proc_nr, &sig_map); /* get an arbitrary pending signal */
19716 if (NONE == proc_nr) { /* stop if no more pending signals */
19717 break;
19718 } else {
19719 handle_sig(proc_nr, sig_map); /* handle the received signal */
19720 sys_endksig(proc_nr); /* tell kernel it’s done */
19721 }
19722 }
19723 return(SUSPEND); /* prevents sending reply */
19724 }
19726 /*===========================================================================*
19727 * handle_sig *
19728 *===========================================================================*/
19729 PRIVATE void handle_sig(proc_nr, sig_map)
19730 int proc_nr;
19731 sigset_t sig_map;
19732 {
19733 register struct mproc *rmp;
19734 int i;
902 File: servers/pm/signal.c MINIX SOURCE CODE
19735 pid_t proc_id, id;
19736
19737 rmp = &mproc[proc_nr];
19738 if ((rmp->mp_flags & (IN_USE | ZOMBIE)) != IN_USE) return;
19739 proc_id = rmp->mp_pid;
19740 mp = &mproc[0]; /* pretend signals are from PM */
19741 mp->mp_procgrp = rmp->mp_procgrp; /* get process group right */
19742
19743 /* Check each bit in turn to see if a signal is to be sent. Unlike
19744 * kill(), the kernel may collect several unrelated signals for a
19745 * process and pass them to PM in one blow. Thus loop on the bit
19746 * map. For SIGINT and SIGQUIT, use proc_id 0 to indicate a broadcast
19747 * to the recipient’s process group. For SIGKILL, use proc_id -1 to
19748 * indicate a systemwide broadcast.
19749 */
19750 for (i = 1; i <= _NSIG; i++) {
19751 if (!sigismember(&sig_map, i)) continue;
19752 switch (i) {
19753 case SIGINT:
19754 case SIGQUIT:
19755 id = 0; break; /* broadcast to process group */
19756 case SIGKILL:
19757 id = -1; break; /* broadcast to all except INIT */
19758 default:
19759 id = proc_id;
19760 break;
19761 }
19762 check_sig(id, i);
19763 }
19764 }
19766 /*===========================================================================*
19767 * do_alarm *
19768 *===========================================================================*/
19769 PUBLIC int do_alarm()
19770 {
19771 /* Perform the alarm(seconds) system call. */
19772 return(set_alarm(who, m_in.seconds));
19773 }
19775 /*===========================================================================*
19776 * set_alarm *
19777 *===========================================================================*/
19778 PUBLIC int set_alarm(proc_nr, sec)
19779 int proc_nr; /* process that wants the alarm */
19780 int sec; /* how many seconds delay before the signal */
19781 {
19782 /* This routine is used by do_alarm() to set the alarm timer. It is also used
19783 * to turn the timer off when a process exits with the timer still on.
19784 */
19785 clock_t ticks; /* number of ticks for alarm */
19786 clock_t exptime; /* needed for remaining time on previous alarm */
19787 clock_t uptime; /* current system time */
19788 int remaining; /* previous time left in seconds */
19789 int s;
19790
19791 /* First determine remaining time of previous alarm, if set. */
19792 if (mproc[proc_nr].mp_flags & ALARM_ON) {
19793 if ( (s=getuptime(&uptime)) != OK)
19794 panic(__FILE__,"set_alarm couldn’t get uptime", s);
MINIX SOURCE CODE File: servers/pm/signal.c 903
19795 exptime = *tmr_exp_time(&mproc[proc_nr].mp_timer);
19796 remaining = (int) ((exptime - uptime + (HZ-1))/HZ);
19797 if (remaining < 0) remaining = 0;
19798 } else {
19799 remaining = 0;
19800 }
19801
19802 /* Tell the clock task to provide a signal message when the time comes.
19803 *
19804 * Large delays cause a lot of problems. First, the alarm system call
19805 * takes an unsigned seconds count and the library has cast it to an int.
19806 * That probably works, but on return the library will convert "negative"
19807 * unsigneds to errors. Presumably no one checks for these errors, so
19808 * force this call through. Second, If unsigned and long have the same
19809 * size, converting from seconds to ticks can easily overflow. Finally,
19810 * the kernel has similar overflow bugs adding ticks.
19811 *
19812 * Fixing this requires a lot of ugly casts to fit the wrong interface
19813 * types and to avoid overflow traps. ALRM_EXP_TIME has the right type
19814 * (clock_t) although it is declared as long. How can variables like
19815 * this be declared properly without combinatorial explosion of message
19816 * types?
19817 */
19818 ticks = (clock_t) (HZ * (unsigned long) (unsigned) sec);
19819 if ( (unsigned long) ticks / HZ != (unsigned) sec)
19820 ticks = LONG_MAX; /* eternity (really TMR_NEVER) */
19821
19822 if (ticks != 0) {
19823 pm_set_timer(&mproc[proc_nr].mp_timer, ticks, cause_sigalrm, proc_nr);
19824 mproc[proc_nr].mp_flags |= ALARM_ON;
19825 } else if (mproc[proc_nr].mp_flags & ALARM_ON) {
19826 pm_cancel_timer(&mproc[proc_nr].mp_timer);
19827 mproc[proc_nr].mp_flags &= ˜ALARM_ON;
19828 }
19829 return(remaining);
19830 }
19832 /*===========================================================================*
19833 * cause_sigalrm *
19834 *===========================================================================*/
19835 PRIVATE void cause_sigalrm(tp)
19836 struct timer *tp;
19837 {
19838 int proc_nr;
19839 register struct mproc *rmp;
19840
19841 proc_nr = tmr_arg(tp)->ta_int; /* get process from timer */
19842 rmp = &mproc[proc_nr];
19843
19844 if ((rmp->mp_flags & (IN_USE | ZOMBIE)) != IN_USE) return;
19845 if ((rmp->mp_flags & ALARM_ON) == 0) return;
19846 rmp->mp_flags &= ˜ALARM_ON;
19847 check_sig(rmp->mp_pid, SIGALRM);
19848 }
19850 /*===========================================================================*
19851 * do_pause *
19852 *===========================================================================*/
19853 PUBLIC int do_pause()
19854 {
904 File: servers/pm/signal.c MINIX SOURCE CODE
19855 /* Perform the pause() system call. */
19856
19857 mp->mp_flags |= PAUSED;
19858 return(SUSPEND);
19859 }
19861 /*===========================================================================*
19862 * sig_proc *
19863 *===========================================================================*/
19864 PUBLIC void sig_proc(rmp, signo)
19865 register struct mproc *rmp; /* pointer to the process to be signaled */
19866 int signo; /* signal to send to process (1 to _NSIG) */
19867 {
19868 /* Send a signal to a process. Check to see if the signal is to be caught,
19869 * ignored, tranformed into a message (for system processes) or blocked.
19870 * - If the signal is to be transformed into a message, request the KERNEL to
19871 * send the target process a system notification with the pending signal as an
19872 * argument.
19873 * - If the signal is to be caught, request the KERNEL to push a sigcontext
19874 * structure and a sigframe structure onto the catcher’s stack. Also, KERNEL
19875 * will reset the program counter and stack pointer, so that when the process
19876 * next runs, it will be executing the signal handler. When the signal handler
19877 * returns, sigreturn(2) will be called. Then KERNEL will restore the signal
19878 * context from the sigcontext structure.
19879 * If there is insufficient stack space, kill the process.
19880 */
19881
19882 vir_bytes new_sp;
19883 int s;
19884 int slot;
19885 int sigflags;
19886 struct sigmsg sm;
19887
19888 slot = (int) (rmp - mproc);
19889 if ((rmp->mp_flags & (IN_USE | ZOMBIE)) != IN_USE) {
19890 printf("PM: signal %d sent to %s process %d\n",
19891 signo, (rmp->mp_flags & ZOMBIE) ? "zombie" : "dead", slot);
19892 panic(__FILE__,"", NO_NUM);
19893 }
19894 if ((rmp->mp_flags & TRACED) && signo != SIGKILL) {
19895 /* A traced process has special handling. */
19896 unpause(slot);
19897 stop_proc(rmp, signo); /* a signal causes it to stop */
19898 return;
19899 }
19900 /* Some signals are ignored by default. */
19901 if (sigismember(&rmp->mp_ignore, signo)) {
19902 return;
19903 }
19904 if (sigismember(&rmp->mp_sigmask, signo)) {
19905 /* Signal should be blocked. */
19906 sigaddset(&rmp->mp_sigpending, signo);
19907 return;
19908 }
19909 sigflags = rmp->mp_sigact[signo].sa_flags;
19910 if (sigismember(&rmp->mp_catch, signo)) {
19911 if (rmp->mp_flags & SIGSUSPENDED)
19912 sm.sm_mask = rmp->mp_sigmask2;
19913 else
19914 sm.sm_mask = rmp->mp_sigmask;
MINIX SOURCE CODE File: servers/pm/signal.c 905
19915 sm.sm_signo = signo;
19916 sm.sm_sighandler = (vir_bytes) rmp->mp_sigact[signo].sa_handler;
19917 sm.sm_sigreturn = rmp->mp_sigreturn;
19918 if ((s=get_stack_ptr(slot, &new_sp)) != OK)
19919 panic(__FILE__,"couldn’t get new stack pointer",s);
19920 sm.sm_stkptr = new_sp;
19921
19922 /* Make room for the sigcontext and sigframe struct. */
19923 new_sp -= sizeof(struct sigcontext)
19924 + 3 * sizeof(char *) + 2 * sizeof(int);
19925
19926 if (adjust(rmp, rmp->mp_seg[D].mem_len, new_sp) != OK)
19927 goto doterminate;
19928
19929 rmp->mp_sigmask |= rmp->mp_sigact[signo].sa_mask;
19930 if (sigflags & SA_NODEFER)
19931 sigdelset(&rmp->mp_sigmask, signo);
19932 else
19933 sigaddset(&rmp->mp_sigmask, signo);
19934
19935 if (sigflags & SA_RESETHAND) {
19936 sigdelset(&rmp->mp_catch, signo);
19937 rmp->mp_sigact[signo].sa_handler = SIG_DFL;
19938 }
19939
19940 if (OK == (s=sys_sigsend(slot, &sm))) {
19941
19942 sigdelset(&rmp->mp_sigpending, signo);
19943 /* If process is hanging on PAUSE, WAIT, SIGSUSPEND, tty,
19944 * pipe, etc., release it.
19945 */
19946 unpause(slot);
19947 return;
19948 }
19949 panic(__FILE__, "warning, sys_sigsend failed", s);
19950 }
19951 else if (sigismember(&rmp->mp_sig2mess, signo)) {
19952 if (OK != (s=sys_kill(slot,signo)))
19953 panic(__FILE__, "warning, sys_kill failed", s);
19954 return;
19955 }
19956
19957 doterminate:
19958 /* Signal should not or cannot be caught. Take default action. */
19959 if (sigismember(&ign_sset, signo)) return;
19960
19961 rmp->mp_sigstatus = (char) signo;
19962 if (sigismember(&core_sset, signo)) {
19963 /* Switch to the user’s FS environment and dump core. */
19964 tell_fs(CHDIR, slot, FALSE, 0);
19965 dump_core(rmp);
19966 }
19967 pm_exit(rmp, 0); /* terminate process */
19968 }
19970 /*===========================================================================*
19971 * check_sig *
19972 *===========================================================================*/
19973 PUBLIC int check_sig(proc_id, signo)
19974 pid_t proc_id; /* pid of proc to sig, or 0 or -1, or -pgrp */
906 File: servers/pm/signal.c MINIX SOURCE CODE
19975 int signo; /* signal to send to process (0 to _NSIG) */
19976 {
19977 /* Check to see if it is possible to send a signal. The signal may have to be
19978 * sent to a group of processes. This routine is invoked by the KILL system
19979 * call, and also when the kernel catches a DEL or other signal.
19980 */
19981
19982 register struct mproc *rmp;
19983 int count; /* count # of signals sent */
19984 int error_code;
19985
19986 if (signo < 0 || signo > _NSIG) return(EINVAL);
19987
19988 /* Return EINVAL for attempts to send SIGKILL to INIT alone. */
19989 if (proc_id == INIT_PID && signo == SIGKILL) return(EINVAL);
19990
19991 /* Search the proc table for processes to signal. (See forkexit.c about
19992 * pid magic.)
19993 */
19994 count = 0;
19995 error_code = ESRCH;
19996 for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++) {
19997 if (!(rmp->mp_flags & IN_USE)) continue;
19998 if ((rmp->mp_flags & ZOMBIE) && signo != 0) continue;
19999
20000 /* Check for selection. */
20001 if (proc_id > 0 && proc_id != rmp->mp_pid) continue;
20002 if (proc_id == 0 && mp->mp_procgrp != rmp->mp_procgrp) continue;
20003 if (proc_id == -1 && rmp->mp_pid <= INIT_PID) continue;
20004 if (proc_id < -1 && rmp->mp_procgrp != -proc_id) continue;
20005
20006 /* Check for permission. */
20007 if (mp->mp_effuid != SUPER_USER
20008 && mp->mp_realuid != rmp->mp_realuid
20009 && mp->mp_effuid != rmp->mp_realuid
20010 && mp->mp_realuid != rmp->mp_effuid
20011 && mp->mp_effuid != rmp->mp_effuid) {
20012 error_code = EPERM;
20013 continue;
20014 }
20015
20016 count++;
20017 if (signo == 0) continue;
20018
20019 /* ’sig_proc’ will handle the disposition of the signal. The
20020 * signal may be caught, blocked, ignored, or cause process
20021 * termination, possibly with core dump.
20022 */
20023 sig_proc(rmp, signo);
20024
20025 if (proc_id > 0) break; /* only one process being signaled */
20026 }
20027
20028 /* If the calling process has killed itself, don’t reply. */
20029 if ((mp->mp_flags & (IN_USE | ZOMBIE)) != IN_USE) return(SUSPEND);
20030 return(count > 0 ? OK : error_code);
20031 }
MINIX SOURCE CODE File: servers/pm/signal.c 907
20033 /*===========================================================================*
20034 * check_pending *
20035 *===========================================================================*/
20036 PUBLIC void check_pending(rmp)
20037 register struct mproc *rmp;
20038 {
20039 /* Check to see if any pending signals have been unblocked. The
20040 * first such signal found is delivered.
20041 *
20042 * If multiple pending unmasked signals are found, they will be
20043 * delivered sequentially.
20044 *
20045 * There are several places in this file where the signal mask is
20046 * changed. At each such place, check_pending() should be called to
20047 * check for newly unblocked signals.
20048 */
20049
20050 int i;
20051
20052 for (i = 1; i <= _NSIG; i++) {
20053 if (sigismember(&rmp->mp_sigpending, i) &&
20054 !sigismember(&rmp->mp_sigmask, i)) {
20055 sigdelset(&rmp->mp_sigpending, i);
20056 sig_proc(rmp, i);
20057 break;
20058 }
20059 }
20060 }
20062 /*===========================================================================*
20063 * unpause *
20064 *===========================================================================*/
20065 PRIVATE void unpause(pro)
20066 int pro; /* which process number */
20067 {
20068 /* A signal is to be sent to a process. If that process is hanging on a
20069 * system call, the system call must be terminated with EINTR. Possible
20070 * calls are PAUSE, WAIT, READ and WRITE, the latter two for pipes and ttys.
20071 * First check if the process is hanging on an PM call. If not, tell FS,
20072 * so it can check for READs and WRITEs from pipes, ttys and the like.
20073 */
20074
20075 register struct mproc *rmp;
20076
20077 rmp = &mproc[pro];
20078
20079 /* Check to see if process is hanging on a PAUSE, WAIT or SIGSUSPEND call. */
20080 if (rmp->mp_flags & (PAUSED | WAITING | SIGSUSPENDED)) {
20081 rmp->mp_flags &= ˜(PAUSED | WAITING | SIGSUSPENDED);
20082 setreply(pro, EINTR);
20083 return;
20084 }
20085
20086 /* Process is not hanging on an PM call. Ask FS to take a look. */
20087 tell_fs(UNPAUSE, pro, 0, 0);
20088 }
908 File: servers/pm/signal.c MINIX SOURCE CODE
20090 /*===========================================================================*
20091 * dump_core *
20092 *===========================================================================*/
20093 PRIVATE void dump_core(rmp)
20094 register struct mproc *rmp; /* whose core is to be dumped */
20095 {
20096 /* Make a core dump on the file "core", if possible. */
20097
20098 int s, fd, seg, slot;
20099 vir_bytes current_sp;
20100 long trace_data, trace_off;
20101
20102 slot = (int) (rmp - mproc);
20103
20104 /* Can core file be written? We are operating in the user’s FS environment,
20105 * so no special permission checks are needed.
20106 */
20107 if (rmp->mp_realuid != rmp->mp_effuid) return;
20108 if ( (fd = open(core_name, O_WRONLY | O_CREAT | O_TRUNC | O_NONBLOCK,
20109 CORE_MODE)) < 0) return;
20110 rmp->mp_sigstatus |= DUMPED;
20111
20112 /* Make sure the stack segment is up to date.
20113 * We don’t want adjust() to fail unless current_sp is preposterous,
20114 * but it might fail due to safety checking. Also, we don’t really want
20115 * the adjust() for sending a signal to fail due to safety checking.
20116 * Maybe make SAFETY_BYTES a parameter.
20117 */
20118 if ((s=get_stack_ptr(slot, &current_sp)) != OK)
20119 panic(__FILE__,"couldn’t get new stack pointer",s);
20120 adjust(rmp, rmp->mp_seg[D].mem_len, current_sp);
20121
20122 /* Write the memory map of all segments to begin the core file. */
20123 if (write(fd, (char *) rmp->mp_seg, (unsigned) sizeof rmp->mp_seg)
20124 != (unsigned) sizeof rmp->mp_seg) {
20125 close(fd);
20126 return;
20127 }
20128
20129 /* Write out the whole kernel process table entry to get the regs. */
20130 trace_off = 0;
20131 while (sys_trace(T_GETUSER, slot, trace_off, &trace_data) == OK) {
20132 if (write(fd, (char *) &trace_data, (unsigned) sizeof (long))
20133 != (unsigned) sizeof (long)) {
20134 close(fd);
20135 return;
20136 }
20137 trace_off += sizeof (long);
20138 }
20139
20140 /* Loop through segments and write the segments themselves out. */
20141 for (seg = 0; seg < NR_LOCAL_SEGS; seg++) {
20142 rw_seg(1, fd, slot, seg,
20143 (phys_bytes) rmp->mp_seg[seg].mem_len << CLICK_SHIFT);
20144 }
20145 close(fd);
20146 }